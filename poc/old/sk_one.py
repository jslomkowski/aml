
import datetime
import os
import pickle
import time

import pandas as pd
from scipy.optimize import minimize
from sklearn.datasets import fetch_california_housing
from sklearn.model_selection import train_test_split

from config.sk_settings import sk_settings
from config.transformer_settings import transformer_settings


def model_name(s, timenow):
    """returns name of experiment that will be used in logging

    Parameters
    ----------
    s : dict
        dictionary generated by net_settings function

    Returns
    -------
    str
        strings with name
    """
    name = timenow + ' ' + str(s.__class__).split('.')[-1][0:-2]

    return name


def loss_and_metric(metric, y_train, y_pred_train, y_val, y_pred_val,
                    y_pred_train_opt=None, y_pred_val_opt=None):
    """Extracts error metrics for val and train from tensorflow fit function

    Parameters
    ----------
    history : History callback
        Contains val and train

    Returns
    -------
    list
        list with 4 elements containing train val loss and metric
    """

    err_train_metric = metric(y_train, y_pred_train)
    err_val_metric = metric(y_val, y_pred_val)
    try:
        err_train_metric_opt = metric(y_train, y_pred_train_opt)
        err_val_metric_opt = metric(y_val, y_pred_val_opt)
    except ValueError:
        err_train_metric_opt = float('NaN')
        err_val_metric_opt = float('NaN')

    err_lst = {'err_train_metric': round(err_train_metric, 2),
               'err_val_metric': round(err_val_metric, 2),
               'err_train_metric_opt': round(err_train_metric_opt, 2),
               'err_val_metric_opt': round(err_val_metric_opt, 2)}
    return err_lst


def save_model(model, name):
    """Creates model directory if not present. Saves trained model with
    model string

    Parameters
    ----------
    model : model
        tensorflow model object
    name : str
        name for model generated by model_name function
    """
    if not os.path.exists('models'):
        os.makedirs('models')
    with open('models/' + name, 'wb') as file:
        pickle.dump(model, file)


def save_results(res, timenow):
    """Creates results directory if not present. Saves results report.

    Parameters
    ----------
    res : list
        list with results.
    """
    if not os.path.exists('results'):
        os.makedirs('results')
    res = pd.DataFrame(res).sort_values('err_val_metric')
    res.to_excel('results/res_list_' + timenow + '.xlsx', index=False)


def optimize_model(metric, y_train, y_pred_train, y_pred_val):
    """optimizes forecast using linear programming

    Parameters
    ----------
    metric : sklearn metric
        metric that will be used to optimize y_pred
    y_train : array or series
        true values from training set
    y_pred_train : array or series
        prediction made on training set
    y_pred_val : array or series
        prediction made on validation set
    """
    def objective(x):
        return metric(y_train, y_pred_train * x)
    x0 = 1.0
    sol = minimize(objective, x0)
    weight = round(sol.x[0], 2)
    y_pred_train_opt = y_pred_train * weight
    y_pred_val_opt = y_pred_val * weight
    return y_pred_train_opt, y_pred_val_opt, weight


def fit_predict(s, X_train, y_train, X_val):
    """Fit model and generate predictions

    Parameters
    ----------
    s : dict
        config from sk_settings
    X_train : df or array
        training set
    y_train : df or array
        true anwsers to training set
    X_val : df or array
        validation set

    Returns
    -------
    string and array
        returns fit time and predictions for train and test set
    """
    print(s['metrics'].__name__, str(s['model'].__class__).rsplit(
        '.', 1)[-1].replace("'>", ""), s['optimize'])
    fit_time = time.time()
    s['model'].fit(X_train, y_train)
    fit_time = round(time.time() - fit_time, 2)
    y_pred_train = s['model'].predict(X_train)
    y_pred_val = s['model'].predict(X_val)
    return fit_time, y_pred_train, y_pred_val


def evaluate_sk_model(df, target):

    X = df.drop(target, axis=1)
    y = df[target]

    transformer_list = transformer_settings()
    sk_settings_list = sk_settings()

    timenow = datetime.datetime.now().strftime('%Y-%m-%d %H-%M-%S')

    res = []
    for t in transformer_list:
        transformations = [str(v.__class__).rsplit(
            '.', 1)[-1].replace("'>", "")for v in t.values()]
        print(transformations)

        for value in t.values():
            X_train, X_val, y_train, y_val = train_test_split(
                X, y, test_size=0.2)
            X_train = value.fit_transform(X_train, y_train)
            X_val = value.transform(X_val)

        for s in sk_settings_list:
            name = model_name(s['model'], timenow)
            fit_time, y_pred_train, y_pred_val = fit_predict(
                s, X_train, y_train, X_val)

            if s['optimize']:
                y_pred_train_opt, y_pred_val_opt, weight = optimize_model(
                    s['metrics'], y_train, y_pred_train, y_pred_val)
                err_lst = loss_and_metric(s['metrics'], y_train, y_pred_train, y_val,
                                          y_pred_val, y_pred_train_opt, y_pred_val_opt)
                err_lst['weight'] = weight

            else:
                err_lst = loss_and_metric(s['metrics'], y_train, y_pred_train, y_val,
                                          y_pred_val)
                err_lst['weight'] = float('NaN')

            case = {
                'model_name': name[name.rfind(' ') + 1:],
                'transformations': transformations,
                'metrics': s['metrics'].__name__,
                'fit_time_sec': fit_time,
                'err_train_metric': err_lst['err_train_metric'],
                'err_val_metric': err_lst['err_val_metric'],
                'err_train_metric_opt': err_lst['err_train_metric_opt'],
                'err_val_metric_opt': err_lst['err_val_metric_opt'],
                'val/train ratio': round(err_lst['err_val_metric'] / err_lst['err_train_metric'], 2) if err_lst['err_train_metric'] else 0,
                'weight': err_lst['weight']
            }

            save_model(s, name)
            res.append(case)
    save_results(res, timenow)


cali = fetch_california_housing(as_frame=True)
df = pd.concat([cali['data'], cali['target']], axis=1)

target = 'MedHouseVal'
evaluate_sk_model(df, target)
