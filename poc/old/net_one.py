
import datetime
import os
import time

import pandas as pd
from sklearn.datasets import fetch_california_housing, make_friedman1
from sklearn.model_selection import train_test_split
from tensorflow.keras.callbacks import EarlyStopping, TensorBoard
from tensorflow.keras.layers import Dense
from tensorflow.keras.models import Sequential

from config.net_settings import net_settings
from config.transformer_settings import transformer_settings


def net(X_train, hidden_layers, neurons1, neurons2, neurons3):
    """Creates Sequential model of your choice

    Returns
    -------
    model
        dense layer model
    """
    model = Sequential()
    model.add(Dense(neurons1, input_dim=X_train.shape[1], activation='relu'))
    if hidden_layers >= 2:
        model.add(Dense(neurons2, activation='relu'))
    if hidden_layers >= 3:
        model.add(Dense(neurons3, activation='relu'))
    model.add(Dense(1, activation='relu'))
    # print(model.summary())
    return model


def model_name(s, timenow):
    """returns name anda time of experiment that will be used in logging

    Parameters
    ----------
    s : dict
        dictionary generated by net_settings function

    Returns
    -------
    str
        strings with time and name
    """
    name = timenow + ' ' + \
        str(s['loss']) + ' ' + str(s['metrics']) + ' ' + \
        str(s['optimizer']) + ' ' + str(s['batch_size']) + ' ' + \
        str(s['epochs']) + ' ' + str(s['neurons1']) + ' ' + str(s['neurons2']) \
        + ' ' + str(s['neurons3'])
    return name


def save_log(name):
    """Creates log dir if not present. Creates path for tensorboard logs

    Parameters
    ----------
    name : str
        string with log name from model_name function

    Returns
    -------
    str
        path to tensorboard log
    """
    if not os.path.exists('logs'):
        os.makedirs('logs')
    logdir = 'logs/' + name
    return logdir


def save_model(model, name):
    """Creates model directory if not present. Saves trained model with
    model string

    Parameters
    ----------
    model : model
        tensorflow model object
    name : str
        name for model generated by model_name function
    """
    if not os.path.exists('models'):
        os.makedirs('models')
    model.save('models/' + name + '.h5')
    with open('models/' + name + '.csv', 'w') as fh:
        model.summary(print_fn=lambda x: fh.write(x + '\n'))


def save_results(res, timenow):
    """Creates results directory if not present. Saves results report.

    Parameters
    ----------
    res : list
        list with results.
    """
    if not os.path.exists('results'):
        os.makedirs('results')
    res = pd.DataFrame(res).sort_values('err_val_loss')
    res.to_excel('results/res_list_' + timenow + '.xlsx', index=False)


def loss_and_metric(history):
    """Extracts error metrics for val and train from tensorflow fit function

    Parameters
    ----------
    history : History callback
        Contains val and train

    Returns
    -------
    list
        list with 4 elements containing train val loss and metric
    """
    hist_lst = list(history.history.keys())
    if len(hist_lst) == 2:
        err_train_loss = history.history[hist_lst[0]][-1]
        err_val_loss = history.history[hist_lst[1]][-1]
        err_train_metric = float('NaN')
        err_val_metric = float('NaN')

    else:
        err_train_loss = history.history[hist_lst[0]][-1]
        err_val_loss = history.history[hist_lst[2]][-1]
        err_train_metric = history.history[hist_lst[1]][-1]
        err_val_metric = history.history[hist_lst[3]][-1]
    err_lst = {'err_train_loss': round(err_train_loss, 2),
               'err_train_metric': round(err_train_metric, 2),
               'err_val_loss': round(err_val_loss, 2),
               'err_val_metric': round(err_val_metric, 2)}
    return err_lst


def fit_predict(s, name, X_train, y_train, X_val, y_val):

    tb = TensorBoard(log_dir=save_log(name),
                     histogram_freq=0,
                     profile_batch=0)
    es = EarlyStopping(monitor='val_loss',
                       mode='auto',
                       verbose=0,
                       patience=5)

    model = net(X_train, s['layers'], s['neurons1'],
                s['neurons2'], s['neurons3'])
    model.compile(optimizer=s['optimizer'],
                  loss=s['loss'],
                  metrics=s['metrics'])

    fit_time = time.time()
    history = model.fit(X_train, y_train,
                        batch_size=s['batch_size'],
                        epochs=s['epochs'],
                        verbose=0,
                        validation_data=(X_val, y_val),
                        callbacks=[
                            tb,
                            es
                        ],
                        )
    fit_time = round(time.time() - fit_time, 2)
    return fit_time, history, model


def evaluate_net_model(df, target):

    X = df.drop(target, axis=1)
    y = df[target]

    transformer_list = transformer_settings()
    net_settings_list = net_settings()

    timenow = datetime.datetime.now().strftime('%Y-%m-%d %H-%M-%S')

    res = []
    for t in transformer_list:
        transformations = [str(v.__class__).rsplit(
            '.', 1)[-1].replace("'>", "")for v in t.values()]
        print(transformations)

        for value in t.values():
            X_train, X_val, y_train, y_val = train_test_split(
                X, y, test_size=0.2)
            X_train = value.fit_transform(X_train, y_train)
            X_val = value.transform(X_val)

        for s in net_settings_list:
            print(s)

            name = model_name(s, timenow)
            fit_time, history, model = fit_predict(
                s, name, X_train, y_train, X_val, y_val)
            err_lst = loss_and_metric(history)

            case = {
                'loss': s['loss'],
                'metrics': s['metrics'],
                'optimizer': s['optimizer'],
                'batch_size': s['batch_size'],
                'epochs': s['epochs'],
                'transformations': transformations,
                'fit_time_sec': str(fit_time),
                'err_train_loss': err_lst['err_train_loss'],
                'err_train_metric': err_lst['err_train_metric'],
                'err_val_loss': err_lst['err_val_loss'],
                'err_val_metric': err_lst['err_val_metric'],
                'val/train ratio': round(err_lst['err_val_metric'] / err_lst['err_train_metric'], 2) if err_lst['err_train_metric'] else 0,
                'layers': s['layers'],
                'neurons1': s['neurons1'],
                'neurons2': s['neurons2'],
                'neurons3': s['neurons3']
            }

            save_model(model, name)
            res.append(case)
    save_results(res, timenow)


cali = fetch_california_housing(as_frame=True)
df = pd.concat([cali['data'], cali['target']], axis=1)

target = 'MedHouseVal'
evaluate_net_model(df, target)
# tensorboard --logdir logs
